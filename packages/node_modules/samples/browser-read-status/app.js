/* eslint-env browser */

/* global ciscospark */ // from bundle.js

/* eslint-disable no-console */
/* eslint-disable require-jsdoc */

// Declare some globals that we'll need throughout.
let webex;
const userInfo = {};

// Save fields in localStorage so we don't have to retype them
// every time we reload the page.
[
  'access-token'
].forEach((id) => {
  const el = document.getElementById(id);

  el.value = localStorage.getItem(id);
  el.addEventListener('change', (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

// Connect to Webex Teams and listen for message events.
function authorize() {
  webex = ciscospark.init({
    config: {

    },
    credentials: {
      access_token: document.getElementById('access-token').value
    }
  });

  if (webex.canAuthorize) {
    return Promise.resolve(webex.canAuthorize);
  }

  return Promise.reject(webex.canAuthorize);
}

// Handle a button push on the "Initialize" button
document.getElementById('credentials').addEventListener('submit', (event) => {
  // Don't reload the page when we submit the form.
  event.preventDefault();

  // Authorize with token and update UI
  authorize()
    .then(() => {
      console.log('connected');
      updateStatus(true);
      webex.people.get('me').then((me) => {
        userInfo.me = me;
      });

      // Register for room events
      webex.rooms.listen()
        .then(() => {
          console.log('listening to room events');
          // Fetch the list of rooms this user is a member off
          webex.rooms.listWithReadStatus()
            .then((rooms) => processInitialRoomStatus(rooms))
            .catch((e) => {
              console.error(`rooms.listWithReadStatus failed: ${e}`);
              updateStatus(false);
            });

          webex.rooms.on('updated', (room) => {
            console.log('room updated event');
            console.log(room);
            processRoomUpdated(room);
          });
        })
        .catch((err) => {
          console.error(`error listening to rooms: ${err}`);
          updateStatus(false);
        });

      // Register for message events
      webex.messages.listen()
        .then(() => {
          console.log('listening to message events');
          webex.messages.on('created', (message) => {
            console.log('message created event:');
            console.log(message);
            processMessageCreated(message);
          });
        })
        .catch((err) => {
          console.error(`error listening to messages: ${err}`);
          updateStatus(false);
        });

      // Register for membership events
      webex.memberships.listen()
        .then(() => {
          console.log('listening to membership events');
          webex.memberships.on('created', (membership) => {
            console.log('membership created event');
            console.log(membership);
            processMembershipCreated(membership);
          });
          webex.memberships.on('deleted', (membership) => {
            console.log('membership deleted event');
            console.log(membership);
            processMembershipDeleted(membership);
          });
          webex.memberships.on('seen', (membership) => {
            console.log('membership seen (read receipt) event');
            console.log(membership);
            processMembershipSeen(membership);
          });
        })
        .catch((err) => {
          console.error(`error listening to memberships: ${err}`);
          updateStatus(false);
        });
    })
    .catch((err) => {
      console.error(`cannot authorize: ${err}`);
    });
});

// Update the UI after login
function updateStatus(authorized) {
  const status = document.getElementById('connection-status');

  if (authorized) {
    status.innerHTML = 'initialized';
    status.classList.remove('label-warning');
    status.classList.remove('label-error');
    status.classList.add('label-success');
    document.getElementById('connect').disabled = true;
    document.getElementById('initializing-message').innerHTML = 'Looking up initial space status...';
  }
  else {
    status.innerHTML = 'unauthorized';
    status.classList.remove('label-warning');
    status.classList.add('label-error');
    document.getElementById('connect').disabled = false;
    document.getElementById('initializing-message').innerHTML = '';
  }
}

// Handle a button push on the "Mark as Read" button
document.getElementById('mark-as-read').addEventListener('submit', (event) => {
  // Don't reload the page when we submit the form.
  event.preventDefault();
  document.getElementById('mark-as-read-button').disabled = true;
  webex.memberships.updateLastSeen(userInfo.lastMessage.data)
    .catch((e) => console.error(`Failed to mark message as read ${e}`));
});

// Update the Table UI after we have initial room status
function updateSpaceTable(userInfo) {
  // Setup the elements in the space info table
  document.getElementById('read-count').innerHTML = userInfo.readSpacesCount;
  document.getElementById('last-read-space-title').innerHTML =
    userInfo.lastRead.title;
  document.getElementById('last-read-space-current-members').innerHTML =
    userInfo.lastRead.countCaughtUpMembers;
  document.getElementById('last-read-space-behind-members').innerHTML =
    userInfo.lastRead.countBehindMembers;
  document.getElementById('unread-count').innerHTML =
    userInfo.unreadSpacesCount;
  document.getElementById('last-unread-space-title').innerHTML =
    userInfo.lastUnread.title;
  document.getElementById('last-unread-space-current-members').innerHTML =
    userInfo.lastUnread.countCaughtUpMembers;
  document.getElementById('last-unread-space-behind-members').innerHTML =
    userInfo.lastUnread.countBehindMembers;

  // Set up the elements in the read receipt table
  if ('data' in userInfo.lastMembershipSeen) {
    document.getElementById('membership-seen-time').innerHTML =
      userInfo.lastMembershipSeen.data.created;
    document.getElementById('membership-seen-user').innerHTML =
      userInfo.lastMembershipSeen.data.personDisplayName;
    document.getElementById('membership-seen-space').innerHTML =
    userInfo.lastMembershipSeen.data.roomTitle;
    document.getElementById('membership-seen-message').innerHTML =
    userInfo.lastMembershipSeen.data.lastSeenId;
  }

  // Set up the elements in the last message table
  if ('data' in userInfo.lastMessage) {
    document.getElementById('message-sent-time').innerHTML =
      userInfo.lastMessage.created;
    document.getElementById('message-author').innerHTML =
      userInfo.lastMessage.data.personEmail;
    document.getElementById('message-space').innerHTML =
    userInfo.lastMessage.data.roomTitle;
    document.getElementById('message').innerHTML =
    userInfo.lastMessage.data.text;
  }
}

async function processInitialRoomStatus(roomStates) {
  if (!('me' in userInfo)) {
    console.error('Failed to get authorized user person info.');

    return updateStatus(false);
  }
  document.getElementById('header-one').innerHTML =
    `<h1>Read Status for ${userInfo.me.displayName}:<h1>`;

  // Hide the login form
  document.getElementById('initial-login').style.display = 'none';

  // Initialize the message and read receipt objects
  userInfo.lastMembershipSeen = {};
  userInfo.lastMessage = {};

  // Parse the roomStates
  if ((!('items' in roomStates)) || (!Array.isArray(roomStates.items))) {
    console.error('No item array returned by the rooms.listWithReadStatus()!');

    return updateStatus(false);
  }
  let msg = document.getElementById('initializing-message').innerHTML;

  msg += `<br>${userInfo.me.displayName} is a member of ${roomStates.items.length} spaces.  Calculating read states...`;
  document.getElementById('initializing-message').innerHTML = msg;

  // Generate the initial state
  userInfo.roomStates = [];
  userInfo.unreadSpacesCount = 0;
  userInfo.lastUnread = {};
  userInfo.readSpacesCount = 0;
  userInfo.lastRead = {};

  for (const roomState of roomStates.items) {
    // if (moment(roomState.lastActivityDate,moment.ISO_8601).valueOf() >
    //   moment(roomState.lastSeenDate,moment.ISO_8601).valueOf())
    if (roomState.lastActivityDate > roomState.lastSeenActivityDate) {
      userInfo.unreadSpacesCount += 1;
      roomState.isUnreadByMe = true;
      if ((!userInfo.lastUnread.id) ||
        (userInfo.lastUnread.lastActivityDate < roomState.lastActivityDate)) {
        userInfo.lastUnread.id = roomState.id;
        userInfo.lastUnread.lastActivityDate = roomState.lastActivityDate;
        userInfo.lastUnread.title = roomState.title ? roomState.title : '';
      }
    }
    else {
      userInfo.readSpacesCount += 1;
      roomState.isUnreadByMe = false;
      if ((!userInfo.lastRead.id) ||
        (userInfo.lastRead.lastSeenActivityDate < roomState.lastSeenActivityDate)) {
        userInfo.lastRead.id = roomState.id;
        userInfo.lastRead.lastSeenActivityDate = roomState.lastSeenActivityDate;
        userInfo.lastRead.lastActivityDate = roomState.lastActivityDate;
        userInfo.lastRead.title = roomState.title ? roomState.title : '';
      }
    }
    userInfo.roomStates.unshift(roomState);
  }

  // Get any membership info for the most recent spaces
  try {
    let lastUnreadPromise, lastReadPromise;
    const emptySpaceList = {
      title: '',
      countBehindMembers: '',
      countCaughtUpMembers: ''
    };

    if ('id' in userInfo.lastUnread) {
      lastUnreadPromise = getMemberDetails(userInfo.lastUnread);
    }
    else {
      lastUnreadPromise = Promise.resolve(emptySpaceList);
    }
    if ('id' in userInfo.lastRead) {
      lastReadPromise = getMemberDetails(userInfo.lastRead);
    }
    else {
      lastReadPromise = Promise.resolve(emptySpaceList);
    }

    // sort the array while we are waiting
    userInfo.roomStates.sort((a, b) => a.lastActivityDate < b.lastActivityDate);
    userInfo.lastUnread = await lastUnreadPromise;
    userInfo.lastRead = await lastReadPromise;
  }
  catch (e) {
    console.error('Failed to get details of most recent spaces');

    return updateStatus(false);
  }

  // Show the table
  document.getElementById('space-status').style.display = 'inline';

  return updateSpaceTable(userInfo);
}

async function processRoomUpdated(room) {
  try {
    // Update our cached room info if a space name has changed
    const {id} = room.data;
    const roomIdx =
      userInfo.roomStates.findIndex((x) => x.id === id);
    const r = await webex.rooms.get(room.data);

    userInfo.roomStates[roomIdx].title = r.title;
    if (userInfo.lastUnread.id === r.id) {
      userInfo.lastUnread.title = r.title;
    }
    if (userInfo.lastRead.id === r.id) {
      userInfo.lastRead.title = r.title;
    }

    return updateSpaceTable(userInfo);
  }
  catch (e) {
    console.error(`Failed processing message:created event: ${e}`);

    return false;
  }
}

async function processMessageCreated(message) {
  try {
    if (!('data' in userInfo.lastMessage)) {
      // Hide the instructions on how to get a message after the first one
      document.getElementById('pre-message').style.display = 'none';
      document.getElementById('mark-as-read-button').style.display = 'inline';
    }
    userInfo.lastMessage = message;
    const {roomId} = message.data;
    const roomIdx =
      userInfo.roomStates.findIndex((x) => x.id === roomId);

    if (message.data.personId === userInfo.me.id) {
      document.getElementById('mark-as-read-button').disabled = true;
      // This is now the most recent read space
      userInfo.lastRead = await getMemberDetails({
        id: roomId,
        ...(userInfo.roomStates[roomIdx].title && {title: userInfo.roomStates[roomIdx].title}),
        lastActivityDate: message.created
      });
      userInfo.lastMessage.data.roomTitle = userInfo.lastRead.title;
      // Update the room status list
      userInfo.lastUnread = await updateRoomStatus(message, roomIdx, false);
    }
    else {
      document.getElementById('mark-as-read-button').disabled = false;
      // This is now the latest unread room
      userInfo.lastUnread = await getMemberDetails({
        id: message.data.roomId,
        ...(userInfo.roomStates[roomIdx].title && {title: userInfo.roomStates[roomIdx].title}),
        lastActivityDate: message.created
      });
      userInfo.lastMessage.data.roomTitle = userInfo.lastUnread.title;

      // Update the room status list
      userInfo.lastRead = await updateRoomStatus(message, roomIdx, true);
    }
    // Move this space to the front (most recent activity) of the array
    if (roomIdx > 0) {
      const latestRoom = userInfo.roomStates.splice(roomIdx, 1);

      userInfo.roomStates.unshift(latestRoom[0]);
    }

    return updateSpaceTable(userInfo);
  }
  catch (e) {
    console.error(`Failed processing message:created event: ${e}`);

    return false;
  }
}

async function processMembershipCreated(membership) {
  try {
    // We have been added to a space, add it to our list
    const newRoom = {
      id: membership.data.roomId,
      isUnreadByMe: true,
      lastActivityDate: membership.created
    };

    userInfo.lastUnread = await getMemberDetails(newRoom);
    newRoom.title = userInfo.lastUnread.title;
    newRoom.lastSeenActivityDate = 0;
    userInfo.unreadSpacesCount += 1;
    userInfo.roomStates.unshift(newRoom);

    return updateSpaceTable(userInfo);
  }
  catch (e) {
    console.error(`Failed processing membership:created event: ${e}`);

    return false;
  }
}

async function processMembershipDeleted(membership) {
  try {
    // We have been removed from a space, delete it from our list
    const {roomId} = membership.data;
    const roomIdx =
      userInfo.roomStates.findIndex((x) => x.id === roomId);

    // Update the room status list
    if (userInfo.lastUnread.id === roomId) {
      userInfo.lastUnread = await updateRoomStatus(membership, roomIdx, false);
    }
    if (userInfo.lastRead.id === roomId) {
      userInfo.lastRead = await updateRoomStatus(membership, roomIdx, true);
    }
    if (userInfo.roomStates[roomIdx].isUnreadByMe) {
      userInfo.unreadSpacesCount -= 1;
    }
    else {
      userInfo.readSpacesCount -= 1;
    }
    userInfo.roomStates.splice(roomIdx, 1);

    return updateSpaceTable(userInfo);
  }
  catch (e) {
    console.error(`Failed processing membership:deleted event: ${e}`);

    return false;
  }
}

async function processMembershipSeen(membership) {
  try {
    if (!('data' in userInfo.lastMembershipSeen)) {
      // Hide the instructions on how to get a read receipt after the first one
      document.getElementById('initializing-membership').style.display = 'none';
    }
    userInfo.lastMembershipSeen = membership;
    // Get the space title for display on our form
    const {roomId} = membership.data;
    const roomIdx =
      userInfo.roomStates.findIndex((x) => x.id === roomId);

    if ('title' in userInfo.roomStates[roomIdx]) {
      userInfo.lastMembershipSeen.data.roomTitle =
        userInfo.roomStates[roomIdx].title;
    }
    else {
      const room =
        await webex.rooms.get(userInfo.lastMembershipSeen.data.roomId);

      userInfo.lastMembershipSeen.data.roomTitle = room.title;
    }

    if (membership.actorId === userInfo.me.id) {
      // I sent a read receipt for this room, add it to the read list
      // and find the next most recent unread space for the table
      userInfo.lastUnread = await updateRoomStatus(membership, roomIdx, false);
    }

    return updateSpaceTable(userInfo);
  }
  catch (e) {
    console.error(`Failed processing membership:seen event: ${e}`);

    return false;
  }
}


// Get member details about a space
async function getMemberDetails(roomToUpdate) {
  const roomInfo = roomToUpdate;
  const membershipPromise =
    webex.memberships.listWithReadStatus({roomId: roomInfo.id});

  if (!roomInfo.title) {
    const room = await webex.rooms.get({id: roomInfo.id});

    roomInfo.title = room.title;
  }
  roomInfo.countBehindMembers = 0;
  roomInfo.countCaughtUpMembers = 0;
  const memberships = await membershipPromise;

  for (const membership of memberships.items) {
    if (membership.personId !== userInfo.me.id) {
      if (membership.lastSeenDate < roomInfo.lastActivityDate) {
        roomInfo.countBehindMembers += 1;
      }
      else {
        roomInfo.countCaughtUpMembers += 1;
      }
    }
  }

  return roomInfo;
}

// Update the array of rooms based on the most recent event
// Return the new 'latest' read/unread room as needed
async function updateRoomStatus(event, roomIdx, isUnreadByMe) {
  let newLatestRoom = {
    title: '',
    countBehindMembers: '',
    countCaughtUpMembers: ''
  };

  if (userInfo.roomStates[roomIdx].isUnreadByMe !== isUnreadByMe) {
    // We have a change in status for a space update the tables
    userInfo.roomStates[roomIdx].isUnreadByMe = isUnreadByMe;
    if (isUnreadByMe === false) {
      userInfo.readSpacesCount += 1;
      userInfo.unreadSpacesCount -= 1;
    }
    else {
      userInfo.readSpacesCount -= 1;
      userInfo.unreadSpacesCount += 1;
    }
    if (((!isUnreadByMe) && (userInfo.unreadSpacesCount > 0)) ||
    ((isUnreadByMe) && (userInfo.readSpacesCount > 0))) {
      const newIdx =
        userInfo.roomStates.findIndex((x) => x.isUnreadByMe !== isUnreadByMe);

      newLatestRoom = await getMemberDetails({
        id: userInfo.roomStates[newIdx].id,
        ...(userInfo.roomStates[newIdx].title && {title: userInfo.roomStates[newIdx].title}),
        lastActivityDate: userInfo.roomStates[newIdx].lastActivityDate
      });
    }
  }
  // The room state has not changed so we return the existing "latest"
  else if (!isUnreadByMe) {
    newLatestRoom = userInfo.lastUnread;
  }
  else {
    newLatestRoom = userInfo.lastRead;
  }

  return newLatestRoom;
}


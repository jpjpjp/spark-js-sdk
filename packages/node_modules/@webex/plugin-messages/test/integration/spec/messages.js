/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-wdm';
import '@ciscospark/plugin-logger';
import '@ciscospark/plugin-rooms';
import '@ciscospark/plugin-people';
import '@ciscospark/plugin-messages';
import CiscoSpark, {SparkHttpError} from '@ciscospark/spark-core';
import {SDK_EVENT} from '@ciscospark/common';
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import testUsers from '@ciscospark/test-helper-test-users';
import fh from '@ciscospark/test-helper-file';
import {browserOnly, flaky, nodeOnly} from '@ciscospark/test-helper-mocha';
import { validate } from '@ciscospark/common/src/base64';
import { SSL_OP_EPHEMERAL_RSA } from 'constants';

const debug = require('debug')('messages');

const KNOWN_HOSTED_IMAGE_URL = 'https://download.ciscospark.com/test/photo.png';
let expectedEvents = [];

describe('plugin-messages', function () {
  this.timeout(60000);

  let spark;
  let actor;

  before(() => testUsers.create({count: 1})
    .then(([user]) => {
      spark = new CiscoSpark({credentials: user.token});
      spark.people.get('me')
        .then((person) => {
          actor = person;
        });
    }));

  // This was an attempt to "drain the event queue" before the test ends
  // This always completed BEFORE the event handlers were called
  after('#all done()', () => {
    console.error(`Ending with ExpectedEvents Array Length: ${expectedEvents.length}`);
    console.error(`Process existing with ExpectedEvents Array Length: ${expectedEvents.length}`);
    if (expectedEvents.length) {
      for (let i = 0; i < expectedEvents.length; i += 1) {
        console.error(`Never got event for task: ${expectedEvents[i].task}`);
      }
    }
  });

  // This was my "global listener" setup
  // The outside tests passed when the listen function returned
  // The inner tests passed when an event handler was called.
  // describe('#listen()', () => {
  //   it('registers messages event listeners', () => {
  //     expectedEvents = [];

  //     return spark.messages.listen()
  //       .then(() => {
  //         spark.messages.on('created', (message) => {
  //           describe('#message:created()', () => {
  //             it('validates a received message:created event', () => {
  //               validateMessageEvent(message, expectedEvents, actor);
  //             });
  //           });
  //         });
  //         spark.messages.on('deleted', (message) => {
  //           describe('#message:deleted()', () => {
  //             it('validates a received message:deleted event', () => {
  //               validateMessageEvent(message, expectedEvents, actor);
  //             });
  //           });
  //         });
  //       });
  //   });
  // });

  describe('#messages', () => {
    let room;

    // This is where the room is set up for all the tests
    // Sending a message here seems unecessary...
    // Perhaps it somehow validates that the room was properly set up?
    before(() => spark.rooms.create({title: 'Cisco Spark Test Room'})
      .then((r) => {
        room = r;
        const text = 'First Message';

        return spark.messages.create({
          roomId: room.id,
          text
        })
          .then((message) => {
            validateMessage(message, text);
            expectedEvents.push({
              task: text,
              id: message.id,
              event: SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED,
              data: message
            });
          });
      }));

    after(() => {
      if (!room) {
        return Promise.resolve();
      }

      return spark.rooms.remove(room)
        .catch((reason) => {
          console.error('Failed to remove room', reason);
        });
    });

    describe('#create()', () => {
      it.only('posts a message in a room', (done) => {
        const text = 'A test message';

        spark.messages.listen()
          .then(() => {
            spark.messages.on('created', (message) => {
              debug('Handler was called...');
              validateMessageEvent(message, expectedEvents, actor);
              done();
            });

            // spark.messages.on('deleted', (message) => {
            //   describe('#message:deleted()', () => {
            //     it('validates a received message:deleted event', () => {
            //       validateMessageEvent(message, expectedEvents, actor);
            //     });
            //   });
            // });
          });

        spark.messages.create({
          roomId: room.id,
          text
        })
          .then((message) => {
            validateMessage(message, text);
            expectedEvents.push({
              task: 'posts a message in a room',
              id: message.id,
              event: SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED,
              data: message
            });
          });
      });

      it('posts a file to a room by specifying the file\'s url', () => spark.messages.create({
        roomId: room.id,
        file: KNOWN_HOSTED_IMAGE_URL
      })
        .then((message) => {
          validateMessage(message, '', 1);
          expectedEvents.push({
            task: 'posts a file to a room by specifying the file\'s url',
            id: message.id,
            event: SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED,
            data: message
          });
        }));

      let blob, buffer;

      browserOnly(before)(() => fh.fetch('sample-image-small-one.png')
        .then((file) => {
          blob = file;

          return new Promise((resolve) => {
            /* global FileReader */
            const fileReader = new FileReader();

            fileReader.onload = function () {
              buffer = this.result;
              resolve();
            };
            fileReader.readAsArrayBuffer(blob);
          });
        }));

      nodeOnly(before)(() => fh.fetchWithoutMagic('sample-image-small-one.png')
        .then((file) => {
          buffer = file;
        }));

      browserOnly(it)('posts a file to a room by directly supplying its blob', () => spark.messages.create({
        roomId: room.id,
        file: blob
      })
        .then((message) => {
          validateMessage(message, '', 1);
          expectedEvents.push({
            task: 'posts a file to a room by directly supplying its blob',
            id: message.id,
            event: SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED,
            data: message
          });
        }));

      // Disabling it gating pipelines because it failes a lot and we get
      // mostly adequate coverage via blob upload
      flaky(it, process.env.SKIP_FLAKY_TESTS)('posts a file to a room by directly supplying its buffer', () => spark.messages.create({
        roomId: room.id,
        file: buffer
      })
        .then((message) => {
          validateMessage(message, '', 1);
          expectedEvents.push({
            task: 'posts a file to a room by directly supplying its buffer',
            id: message.id,
            event: SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED,
            data: message
          });
        }));

      const text = 'A File';

      it('posts a file with a message to a room by specifying the file\'s url', () => spark.messages.create({
        roomId: room.id,
        file: KNOWN_HOSTED_IMAGE_URL,
        text
      })
        .then((message) => {
          validateMessage(message, text, 1);
          expectedEvents.push({
            task: 'posts a file with a message to a room by specifying the file\'s url',
            id: message.id,
            event: SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED,
            data: message
          });
        }));
    });

    describe('#remove()', () => {
      let message;
      const text = 'This message will be deleted';

      beforeEach(() => spark.messages.create({
        roomId: room.id,
        text
      })
        .then((m) => {
          message = m;
          validateMessage(message, text);
          expectedEvents.push({
            task: 'create a messge to delete',
            id: message.id,
            event: SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED,
            data: message
          });
        }));

      it('deletes a single message', () => spark.messages.remove(message)
        .then((body) => {
          assert.notOk(body);
          expectedEvents.push({
            task: 'deletes a single message',
            id: message.id,
            event: SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED,
            data: message
          });

          return assert.isRejected(spark.messages.get(message));
        })
        .then((reason) => {
          assert.instanceOf(reason, SparkHttpError.NotFound);
        }));
    });

    describe('get()', () => {
      let message;
      const text = 'A test message';

      before(() => {
        // The above tests validate all the events
        // Turn off the event listener for the remainder of the tests
        spark.messages.off('created');
        spark.messages.off('deleted');
        
        return spark.messages.create({
          roomId: room.id,
          text
        })
          .then((m) => {
            message = m;
            validateMessage(message, text);
          });
      });

      it('returns a single message', () => spark.messages.get(message)
        .then((m) => {
          assert.isMessage(m);
          assert.deepEqual(m, message);
        }));
    });


    // TODO move this function (and its test) to plugin-memberships
    describe('#markAsRead()', () => {
      // Its not clear why these internal calls were here
      // The disconnect stopped the event handlers from being called
      // before(() => spark.internal.mercury.connect());
      //after(() => spark.internal.mercury.disconnect());

      it('marks a message as read', () => {
        const text = 'A test message';

        return spark.messages.create({
          roomId: room.id,
          text
        })
          .then((message) => spark.messages.markAsRead(message)
            .then((ack) => {
              assert.isDefined(ack);
              assert.isDefined(ack.id);
              assert.equal(ack.messageId, message.id);
              assert.isDefined(ack.markedAsRead);
            }));
      });
    });

    describe('#list()', () => {
      let room;

      before(() => spark.rooms.create({
        title: 'Room List Test'
      })
        .then((r) => {
          room = r;
        }));

      before(() => [1, 2, 3].reduce((promise, value) => promise.then(() => spark.messages.create({
        roomId: room.id,
        text: `message: ${value}`
      })), Promise.resolve()));

      it('returns all messages for a room', () => spark.messages.list({roomId: room.id})
        .then((messages) => {
          assert.isDefined(messages);
          assert.lengthOf(messages, 3);
          for (const message of messages) {
            assert.isMessage(message);
          }
        }));

      it('returns a bounded set of messages for a room', () => {
        const spy = sinon.spy();

        return spark.messages.list({roomId: room.id, max: 2})
          .then((messages) => {
            assert.lengthOf(messages, 2);

            return (function f(page) {
              for (const message of page) {
                spy(message.id);
              }

              if (page.hasNext()) {
                return page.next().then(f);
              }

              return Promise.resolve();
            }(messages));
          })
          .then(() => {
            assert.calledThrice(spy);
          });
      });
    });
  });


//   These were attempts to "drain the event stack"
//   describe('#waitForEvents()', () => {
//     const secondsToWait = 5;

//     it(`waits for ${secondsToWait} seconds for expected events`, (done) => {
//       process.nextTick(async () => {
//         console.error(`Sleeping with ExpectedEvents Array Length: ${expectedEvents.length}`);
//         await sleep(1000);
//         console.error(`Woke with ExpectedEvents Array Length: ${expectedEvents.length}`);
//         if (expectedEvents.length) {
//           for (let i = 0; i < expectedEvents.length; i += 1) {
//             console.error(`Never got event for task: ${expectedEvents[i].task}`);
//           }
//         }
//         else {
//           console.error(`Ending with ExpectedEvents Array Length: ${expectedEvents.length}`);
//         }
//         done();
//       });
// //      setTimeout(() => {
//       //   done();
//       // }, secondsToWait * 1000); // timeout with an error in one second
//     });
//   });

  // describe('#waitForEvents()', () => {
  //   const secondsToWait = 5;

  //   it(`waits for ${secondsToWait} seconds for expected events`, (done) => {
  //     this.timeout(secondsToWait * 1000);

  //     waitForEventsToDrain(expectedEvents, secondsToWait)
  //       .then(() => {
  //         console.error('Wait test resolved');
  //         done();
  //       }).catch(() => {
  //         console.error('Wait test rejected');
  //         done();
  //       });
  //   });
  // });
});

// Since I could not "drain the event stack" inside of the test framework.
// this simply prints out data about the state of the stack when the process exits
process.on('exit', () => {
  console.error(`Process existing with ExpectedEvents Array Length: ${expectedEvents.length}`);
  if (expectedEvents.length) {
    for (let i = 0; i < expectedEvents.length; i += 1) {
      console.error(`Never got event for task: ${expectedEvents[i].task}`);
    }
  }
});

// These were also attempts to "give up the processor" to see if we could
// get the event handlers called while the tests were running

// function sleep(ms) {
//   return new Promise((resolve) => setTimeout(resolve, ms));
// }

// async function waitForEventsToDrain(expectedEvents, secondsToWait) {
//   return new Promise(async (resolve, reject) => {
//     let numSecs = 0;

//     console.error('Checking if we need to wait for events before ending...');
//     while ((expectedEvents.length < 10) && (numSecs < secondsToWait)) {
//       console.error(`Waiting ${secondsToWait - numSecs} seconds for ${expectedEvents.length} more events...`);
//       // Wait for exxpected events to arrive
//       // eslint-disable-next-line no-await-in-loop
//       await sleep(1000);
//       numSecs += 1;
//     }
//     if (expectedEvents.length) {
//       for (let i = 0; i < expectedEvents.length; i += 1) {
//         console.error(`Never got event for task: ${expectedEvents[i].task}`);
//       }
//       reject(new Error(`Ending with ExpectedEvents Array Length: ${expectedEvents.length}`));
//     }
//     else {
//       console.error(`Ending with ExpectedEvents Array Length: ${expectedEvents.length}`);
//       resolve();
//     }
//   });
// }

/**
 * Validate a Message object.
 * @param {Object} message
 * @param {String} text -- optional message text to check
 * @param {Boolean} numFiles
 * @returns {void}
 */
function validateMessage(message, text = '', numFiles = 0) {
  assert.isDefined(message);
  assert.isMessage(message);
  if (text) {
    assert.equal(message.text, text);
  }
  if (numFiles) {
    assert.property(message, 'files');
    assert.isDefined(message.files);
    assert.isArray(message.files);
    assert.lengthOf(message.files, numFiles);
  }
}

/**
 * Validate a Message evet.
 * @param {Object} event - message event
 * @param {Array} expectedEvents -- array of expected events
 * @param {Object} actor - person object for user who performed action
 * @returns {void}
 */
function validateMessageEvent(event, expectedEvents, actor) {
  console.error(`Validating Event: ExpectedEvents Array Length: ${expectedEvents.length}`);
  // Inspect the event "webhook" envelope
  assert.isTrue(event.resource === SDK_EVENT.EXTERNAL.RESOURCE.MESSAGES);
  assert.isDefined(event.event);
  assert.isDefined(event.created);
  assert.equal(event.createdBy, actor.id);
  assert.equal(event.orgId, actor.orgId);
  assert.equal(event.ownedBy, 'creator');
  assert.equal(event.status, 'active');
  assert.equal(event.actorId, actor.id);

  // Match this event up to a return value from a previous function call
  assert.isDefined(event.data.id);
  const msgIdx = expectedEvents.findIndex((x) =>
    (x.id === event.data.id) && (x.event === event.event));

  if (msgIdx < 0) {
    // Not every event is being tracked
    return;
  }
  const expectedEvent = expectedEvents[msgIdx];

  expectedEvents.splice(msgIdx, 1);
  console.error(`After splice: ExpectedEvents Array Length: ${expectedEvents.length}`);

  // Ensure event data matches data returned from function call
  assert.equal(event.data.roomId, expectedEvent.data.roomId);
  assert.equal(event.data.personId, expectedEvent.data.personId);
  assert.equal(event.data.personEmail, expectedEvent.data.personEmail);
  assert.equal(event.data.roomType, expectedEvent.data.roomType);
  if (event.event === SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED) {
    return;
  }
  if (expectedEvent.data.text) {
    assert.equal(event.data.text, expectedEvent.data.text);
  }
  if (expectedEvent.data.files) {
    assert.isArray(event.data.files);
    assert.isArray(expectedEvent.data.files);
    assert.equal(event.data.files.length, expectedEvent.data.files.length);
    for (let i = 0; i < expectedEvent.data.files.length; i += 1) {
      // The gateway returned by the API is apialpha.ciscospark.com
      // The gateway returned in the event is api.ciscospark.com -- expected?
      assert.equal(event.data.files[i].substr(event.data.files[i].lastIndexOf('/') + 1),
        expectedEvent.data.files[i].substr(expectedEvent.data.files[i].lastIndexOf('/') + 1));
    }
  }
}

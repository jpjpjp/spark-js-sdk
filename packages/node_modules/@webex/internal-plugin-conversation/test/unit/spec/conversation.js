/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
/* eslint-disable no-underscore-dangle */
import {assert} from '@webex/test-helper-chai';
import MockWebex from '@webex/test-helper-mock-webex';
import sinon from 'sinon';
import Conversation from '@webex/internal-plugin-conversation';

describe('plugin-conversation', () => {
  describe('Conversation', () => {
    let webex;

    const convoUrl = 'https://conv-test.wbx2.com/conversation';

    beforeEach(() => {
      webex = new MockWebex({
        children: {
          conversation: Conversation
        }
      });

      webex.internal.services = {};
      webex.internal.services.get = sinon.stub().returns(Promise.resolve(convoUrl));
      webex.internal.services.getServiceFromClusterId = sinon.stub().returns({url: convoUrl});
    });

    describe('#_inferConversationUrl', () => {
      const testConvo = {test: 'convo'};

      it('Returns given convo if no id', () => webex.internal.conversation._inferConversationUrl(testConvo)
        .then((convo) => {
          assert.notCalled(webex.internal.feature.getFeature);
          assert.notCalled(webex.internal.services.get);
          assert.equal(convo.test, 'convo');
        }));

      describe('HA is disabled', () => {
        beforeEach(() => {
          webex.internal.feature.getFeature = sinon.stub().returns(Promise.resolve(false));
          testConvo.id = 'id1';
        });
        it('returns unmodified convo if URL is defined', () => {
          testConvo.url = 'http://example.com';

          return webex.internal.conversation._inferConversationUrl(testConvo)
            .then((convo) => {
              assert.called(webex.internal.feature.getFeature);
              assert.notCalled(webex.internal.services.get);
              assert.equal(convo.url, 'http://example.com');
            });
        });
        it('builds URL if not defined', () => {
          delete testConvo.url;

          return webex.internal.conversation._inferConversationUrl(testConvo)
            .then((convo) => {
              assert.called(webex.internal.feature.getFeature);
              assert.called(webex.internal.services.get);
              assert.equal(convo.url, `${convoUrl}/conversations/id1`);
            });
        });
      });
      describe('HA is enabled', () => {
        beforeEach(() => {
          webex.internal.feature.getFeature = sinon.stub().returns(Promise.resolve(true));
          testConvo.id = 'id1';
        });
        it('builds URL if already defined', () => {
          testConvo.url = 'https://example.com';

          return webex.internal.conversation._inferConversationUrl(testConvo)
            .then((convo) => {
              assert.called(webex.internal.feature.getFeature);
              assert.called(webex.internal.services.get);
              assert.equal(convo.url, `${convoUrl}/conversations/id1`);
            });
        });
        it('builds URL if not defined', () => {
          delete testConvo.url;

          return webex.internal.conversation._inferConversationUrl(testConvo)
            .then((convo) => {
              assert.called(webex.internal.feature.getFeature);
              assert.called(webex.internal.services.get);
              assert.equal(convo.url, `${convoUrl}/conversations/id1`);
            });
        });
      });
    });

    describe('getConvoUrl', () => {
      it('should not return a promise', () => {
        try {
          webex.internal.conversation.getConvoUrl({url: 'convoUrl'}).then();
        }
        catch (error) {
          assert.equal(error.message, 'webex.internal.conversation.getConvoUrl(...).then is not a function');
        }
      });

      it('should return the url if a url is provided', () => {
        const url = webex.internal.conversation.getConvoUrl({url: convoUrl});

        assert.equal(url, convoUrl);
      });
    });

    describe('#getUrlFromClusterId', () => {
      it('should convert a "us" cluster to WEBEX_CONVERSATION_DEFAULT_CLUSTER cluster', async () => {
        await webex.internal.conversation.getUrlFromClusterId({cluster: 'us'});

        sinon.assert.calledWith(webex.internal.services.getServiceFromClusterId, {clusterId: process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER});
      });

      it('should add the cluster service when missing', async () => {
        await webex.internal.conversation.getUrlFromClusterId({cluster: 'urn:TEAM:us-west-2_r'});

        sinon.assert.calledWith(webex.internal.services.getServiceFromClusterId, {clusterId: 'urn:TEAM:us-west-2_r:identityLookup'});
      });
    });

    describe('paginate', () => {
      it('should throw an error if a page is passed with no links', () => {
        try {
          webex.internal.conversation.paginate({page: {}});
        }
        catch (error) {
          assert.equal(error.message, 'No link to follow for the provided page');
        }
      });
    });

    describe('#getReactionSummaryByParentId()', () => {
      beforeEach(() => {
        webex.request = sinon.stub().returns(Promise.resolve({
          body: {
            children: [
              {type: 'reactionSelfSummary'},
              {type: 'reactionSelfSummary'},
              {type: 'reactionSummary'},
              {type: 'notAReaction'}
            ]
          }
        }));
      });

      it('should call request', () => webex.internal.conversation.getReactionSummaryByParentId(convoUrl, 'test-id')
        .then(() => {
          assert.called(webex.request);
        }));

      it('should not retrieve non reaction summary objects', () => webex.internal.conversation.getReactionSummaryByParentId(convoUrl, 'test-id')
        .then((result) => {
          assert.equal(result.length, 3);
          assert.notInclude(result, {type: 'notAReaction'});
        }));
    });

    describe('#listAllChildActivitiesByParentId()', () => {
      let dayCount = 0;
      const createActivityItemBatch = (itemCount) => {
        const counter = [...Array(itemCount).keys()];

        dayCount += 1;

        return counter.map((n) => ({
          published: new Date(2020, 0, 1, dayCount, n)
        }));
      };

      const createMockChildResponse = (itemsToReturn = 10) => {
        const response = {
          body: {
            items: createActivityItemBatch(itemsToReturn)
          },
          headers: {
            link: '<https://www.cisco.com>; rel=next'
          }
        };

        return response;
      };

      beforeEach(() => {
        webex.request = sinon.stub()
          .onCall(0)
          .returns(Promise.resolve(createMockChildResponse()))
          .onCall(1)
          .returns(Promise.resolve(createMockChildResponse()))
          .onCall(2)
          .returns(Promise.resolve(createMockChildResponse(3)))
          .returns(Promise.resolve(Promise.resolve({
            body: {
              items: []
            },
            headers: {}
          })));
      });
      it('retrieves correct children count', () => webex.internal.conversation.listAllChildActivitiesByParentId({conversationUrl: convoUrl, activityParentId: '123-abc'})
        .then((res) => {
          assert.equal(res.length, 23);
        }));

      it('calls #listChildActivitiesByParentId() to initiate the request', () => {
        const spy = sinon.spy(webex.internal.conversation, 'listChildActivitiesByParentId');

        return webex.internal.conversation.listAllChildActivitiesByParentId({conversationUrl: convoUrl, activityParentId: '123-abc'})
          .then(() => {
            assert(spy.calledOnce);
          });
      });

      it('returns children in ascending published order', () => webex.internal.conversation.listAllChildActivitiesByParentId({conversationUrl: convoUrl, activityParentId: '123-abc'})
        .then((res) => {
          const firstMessageOlderThanLastMessage = res[0].published < res[res.length - 1].published;

          assert.isTrue(firstMessageOlderThanLastMessage, 'activities out of order');
        }));
    });
  });
});
